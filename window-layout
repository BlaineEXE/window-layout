#!/usr/bin/env bash
set -e

# Most windows have their X,Y coordinates shifted by an amount equal to the
# window decorations (titlebar, edges, etc.). There are some programs which
# don't follow this rule.
# This list should contain the name of the program as given by `ps -p PID`
# separated by a single space each.
DECORATION_EXCEPTIONS="konsole"
# Programs known to have X,Y shift:
# - chrome (only if the "Use system title bar and borders" is set)
# - atom, pidgin, thunderbird, paprefs, pactl

USAGE=$(cat << EOF
Usage:
$0 <save|load> [savename] -- save/load window layout with optional savename
$0 list                   -- list saves available to load
$0 -h|--help              -- show this usage message
EOF
)

if [[ $# -lt 1 ]]; then
  echo "$USAGE"
  exit 1
fi
mode="$1"
shift

savename="default"
if [[ $# -ge 1 ]]; then
  savename="$1"
  shift
fi

SAVEPATH="${HOME}/.window-layout/"

save_layout () {
  local savename="$1"
  mkdir -p "${SAVEPATH}"
  rm -f "${SAVEPATH}/${savename}"

  wmctrl -p -G -l | awk '($2 != -1)&&($3 != 0)&&($NF != "Desktop")' | while read window_info; do
    # ID Desktop PID X Y Width Height Host? Title
    echo $window_info
    id="$(echo "$window_info" | awk '{print $1}')"
    pid="$(echo $window_info | awk '{print $3}')"
    process_name="$(ps -p $pid -o comm=)"
    title="$(echo "$window_info" | awk '{print substr($0, index($0, $9))}')"

    # Get desktop, x, y, width, and height info
    desktop="$(echo $window_info | awk '{print $2}')"
    x="$(echo "$window_info" | awk '{print $4}')"
    y="$(echo "$window_info" | awk '{print $5}')"
    width="$(echo "$window_info" | awk '{print $6}')"
    height="$(echo "$window_info" | awk '{print $7}')"

    # Save info to a line in our save file
    echo "$id $desktop $x $y $width $height $process_name '$title'" >> "${SAVEPATH}/${savename}"
  done
}

contains () {
  local list="$1"
  local key="$2"
  [[ "$list" =~ (^|[[:space:]])"$key"($|[[:space:]]) ]] && return 0 || return 1
}

load_layout () {
  local savename="$1"
  cat "${SAVEPATH}/${savename}" | while read window_info; do
    echo $window_info
    # Read info from a line in our save file
    id="$(echo $window_info | cut --delimiter ' ' --fields 1)"
    desktop="$(echo "$window_info" | cut --delimiter ' ' --fields 2)"
    x="$(echo "$window_info" | cut --delimiter ' ' --fields 3)"
    y="$(echo "$window_info" | cut --delimiter ' ' --fields 4)"
    width="$(echo "$window_info" | cut --delimiter ' ' --fields 5)"
    height="$(echo "$window_info" | cut --delimiter ' ' --fields 6)"
    process_name="$(echo $window_info | cut --delimiter ' ' --fields 7)"
    title="$(echo "$window_info" | awk '{print substr($0, index($0, $7))}')"

    # Most programs need x,y adjusted by window decoration amounts.
    # Not sure why this is. I can't find any property unique to these windows
    # that suggests a different way to fix this other than this hard-coding.
    # I've investigated the `xwininfo` of the window ID as well as the
    # `xwininfo` of the parent window ID. Neither suggested a definite
    # relationship between a property and whether the window needs x,y adjusted
    if ! contains "$DECORATION_EXCEPTIONS" "$process_name" ; then
      # Get window decorations
      if ! xprop _NET_FRAME_EXTENTS -id $id ; then
        echo ""
        echo "WARN: Error getting window properties. It might not exist. Continuing."
        continue
      fi
      decoration="$(xprop _NET_FRAME_EXTENTS -id $id | cut --delimiter '=' --fields 2 | tr --delete ' ')"
      decor_left="$(echo $decoration | cut --delimiter ',' --fields 1)"
      # decor_right="$(echo $decoration | cut --delimiter ',' --fields 2)"
      decor_top="$(echo $decoration | cut --delimiter ',' --fields 3)"
      # decor_bottom="$(echo $decoration | cut --delimiter ',' --fields 4)"
      x=$(($x - $decor_left))
      y=$(($y - $decor_top))
      echo "New x,y computed: $x, $y"
    fi

    # Set position and desktop for each window ID
    wmctrl -i -r "$id" -e "0,$x,$y,$width,$height"
    wmctrl -i -r "$id" -t "$desktop"
  done
}

list_saves () {
  ls "${SAVEPATH}"
}

case $mode in
  save)
  save_layout "$savename"
  ;;
  load)
  load_layout "$savename"
  ;;
  list)
  list_saves
  ;;
  -h|--help)
  echo "$USAGE"
  ;;
  *)
  echo "ERR: invalid mode '$mode'"
  echo "$USAGE"
  exit 2
  ;;
esac
